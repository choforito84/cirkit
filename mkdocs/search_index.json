{
    "docs": [
        {
            "location": "/", 
            "text": "Revkit user guide\n\n\nThis is intended to serve as an user guide for Revkit, a reversible logic toolkit program. Revkit is now a part of \nCirKit\n, a toolkit program for logic created by Mathias Soeken at the \u00c9cole Polythechnique Fed\u00e9rale de Lausanne.\n\n\nThis user manual contains a list of most commands in Revkit along with their description, along with a section completely dedicated to examples of the code. \n\n\nAbout the installation\n\n\nAlthough in Cirkit's repository we can find instructions for installing Revkit, here we will detail how to make a clean installation of Revkit inside Ubuntu and inside the Uleth Linux System, a Centos7-based computer network designed for the Computer Science and Mathematics deparment memebers at the University of Lethbridge in Alberta, Canada.\n\n\nCirkit is supported by UNIX-like systems such as MacOS and Linux distributions.\n\n\nRequirements\n\n\nThe following sofware is needed in order to build Revkit\n\n\n\n\ngit\n\n\ncmake (at least version 3.0.0)\n\n\ng++ (at least version 4.9.0) or clang++ (at least version 3.5.0)\n\n\nboost (at least version 1.56.0)\n\n\nGNU MP, and its C++ interface GMP++\n\n\nGNU readline\n\n\n\n\nInternal Package Manager\n\n\nCirKit uses some external (mainly academic) programs that are typically not shipped with Linux distributions.  To ease their installation CirKit provides its own small package manager that can be invoked via \nutils/tools.py\n.  Run    \n\n\nutils/tools.py commands\n\n\n\n\n\nto see a document list of the options of this package manager and learn how it can be executed.  The programs are automatically downloaded and build, binaries are installed in the \next/bin\n folder of CirKit's main directory.\n\n\nIt must be noticed that, if we want to install a program through this package manager and then use in general in our system, we must update the \nPATH\n environment variable using the following command:\n\n\nexport\n \nPATH\n=\npath-to-cirkit\n/ext/bin:\n$PATH\n`\n.\n\n\n\n\n\nThis indicates the system to look for binaries of programs inside the \next/bin\n folder of CirKit's main repository before searching in system folders. \n\n\nInstallation in Ubuntu\n\n\nThe following instructions for installing Revkit in Ubuntu are also included in CirKit's Github repository. First of all, we need to install the dependencies needed for Revkit using Ubuntu's package manager. The following command must be executed from a terminal:\n\n\nsudo apt-get install build-essential git g++ cmake libboost-all-dev libgmp3-dev libxml2-dev zlib1g-dev lapack openblas\n\n\n\n\n\nAfter installing these dependencies, we are ready for cloning the Github repository using the following command: \n\n\ngit clone https://github.com/msoeken/cirkit.git\n\ncd\n cirkit\n\n\n\n\n\nAfter this step, we need to create and update some environment variables of the system. To do that, run the following commands in the same terminal:\n\n\nexport\n \nCIRKIT_HOME\n=\nfull-path-to-cirkit-repository\n\n\nexport\n \nLD_LIBRARY_PATH\n=\n$CIRKIT_HOME\n/ext/lib:\n$LD_LIBRARY_PATH\n\n\nexport\n \nPATH\n=\n$CIRKIT_HOME\n/ext/bin:\n$PATH\n\n\n\n\n\n\nNow, to install Revkit we must run the following commands from the terminal:\n\n\nmkdir build\n\ncd\n build\ncmake -Denable_cirkit-addon-reversible\n=\nON -Denable_cirkit-addon-formal\n=\nON ..\nmake external\nmake revkit\n\n\n\n\n\nThe first two commands create a directory called \"build\" inside of Cirkit main directory and changes the terminal location to it. The following three commands build Revkit from the cmake configuration files created along it.\n\n\nManually installing Boost\n\n\nEven though the Boost library installed from Ubuntu's package manager is higher than the requirement from Revkit (1.58.0 at Ubuntu;s package manager, Revkit requires higher than 1.56.0), this version is fairly old and it can cause some problems when installing Revkit. To avoid this problems, we recommend installing a newer version of Boost (1.64.0) by downloading it from their official website and then installing it. This can be accomplished with the following commands:\n\n\nwget https://dl.bintray.com/boostorg/release/1.64.0/source/boost_1_64_0.tar.gz\ntar xzvf boost_1_64_0.tar.gz\n\ncd\n boost_1_64_0.tar.gz/\nsudo apt-get update\nsudo apt-get install build-essential g++ python-dev autotools-dev libicu-dev build-essential libbz2-dev \n./bootstrap.sh --prefix\n=\n/usr/\n./b2\nsudo ./b2 install \n\n\n\n\n\nThe first three lines downloads, uncompress Boost and changes the terminal direction to Boost main directory. The following two lines use Ubuntu's package manager to install tools needed for Boosts installation. The last three lines compile and install Boost under the '/usr/' directory of the user.\n\n\nInstallation in ULeth linux system\n\n\nTo install Revkit in ULeth linux system we face several problems due to the complexity of the system and to not having root permission. The problems can be listed as the following.\n\n\n\n\nDisk quota issue:\n  The disk space available for each user at the ULeth linux system is low relatively to the system size (the installation is of around 2.5 GB). The solution to this is to install it locally on each computer you are working or using a shared partition in the system. For anyone without much experience with the system, the system administrator assistance is needed.\n\n\nDependencies issue:\n  although all of the dependencies needed to install the program are included in the system, some of them are not updated and can not be used safely by Revkit. \n\n\nCompiling issues:\n As a result of being written in C++, there can be problems compiling it if previous built has failed due to the usage of CCache by GCC. Basically, CCache stores compilations of C/C++ code so that compiling a program several times is made with lower downtime. However, for builds that have failed, CCache uses that same compilation so it forces that any further build have the same error, even if you have corrected it. \n\n\n\n\nSo solve the \nDisk Quota issues\n, the first step in the installation is to a file location in the system must be found with enough free space (more than 3 GB) to clone the github repository and perform the installation. After that, clone the Github repository:\n\n\n~$ git clone https://github.com/msoeken/cirkit.git\n~$ \ncd\n cirkit\n\n\n\n\n\nInstalling dependencies\n\n\nDue to the high dependencies requirements of Cirkit, it can not be installed easily on a system without having root privileges to update and install all of the dependencies needed. However, it can be installed using the internal package manager. In the following we will list each dependency and its status at the ULeth linux system:\n\n\n\n\ngit :\n included in the linux system and updated.\n\n\nGNU MP and GMP++ :\n included in the linux system and updated.\n\n\nGNU readline :\n included in the linux system and updated.\n\n\nGCC :\n included in the linux system but out of date. Cirkit requires a version higher than 4.9.0, meanwhile the system is at 4.8.5.\n\n\ncmake :\n included in the linux system but out of date. Revkit requires a version higher than 3.0.0 and the system is in 2.8.5.\n\n\nboost :\n included in the linux system but out of date. Revkit requires a version higher than 1.56.0 and the system is in 1.53.0.\n\n\n\n\nAlthough it would seem that a simple update made by the system administrator would be enough to be able to install Revkit, Boost and C++ cannot be updated because it generates problems with other programs in the system. \n\n\nCirkit's included package manager allows us to install local versions of the needed programs without the use of root privileges. Inside the main directory of the repository, open a terminal and run the following commands:\n\n\n utils/tools.py install boost\n utils/tools.py install gcc\n utils/tools.py install cmake\n\n\n\n\n\nIt is very likely that the terminal throws an error when installing \ngcc\n, but this problem is not for installing GCC other than for installing other dependencies, in particular, for ISL. After this step, we need to create and update some environment variables of the system. To do that, run the following commands in the same terminal:\n\n\nexport\n \nCIRKIT_HOME\n=\nfull-path-to-cirkit-repository\n\n\nexport\n \nLD_LIBRARY_PATH\n=\n$CIRKIT_HOME\n/ext/lib:\n$LD_LIBRARY_PATH\n\n\nexport\n \nPATH\n=\n$CIRKIT_HOME\n/ext/bin:\n$PATH\n\n\n\n\n\n\nPython API\n\n\nRevkit can also be used inside Python as a module through an API. In order to build the Python API, we need to have installed \nPybind11\n. \nPybind11\n can be installed executing the following commands in any directory of the file system:\n\n\ngit clone https://github.com/pybind/pybind11.git\n\ncd\n pybind11\nmkdir build\n\ncd\n build\ncmake ..\nmake install\n\n\n\n\n\nIt is recommended that the \nmake install\n command is executed as a root user.  It is also recommended to install \npybind11\n package for your python distribution. This can be done through \npip\n with the command \n\n\npip install pybind11\n\n\n\n\n\nAfter installing \npybind11\n, one can build the python API executing the following commands in Cirkit main directory:\n\n\nmkdir build\n\ncd\n build\ncmake -Denable_cirkit-addon-reversible\n=\nON -Denable_cirkit-addon-formal\n=\nON -Dcirkit_ENABLE_PYTHON_API\n=\nON ..\nmake external\nmake revkit_python\n\n\n\n\n\nThe Python API will be build inside the \nbuild/programs\n folder of Cirkit's main repository. After running these commands, we need to update the \nPYTHONPATH\n environment variable so Python finds Revkit module each time we want to import it. This can be done permanently by adding the following line to the \n.bashrc\n file:\n\n\nexport\n \nPYTHONPATH\n=\n$CIRKIT_HOME\n/build/programs", 
            "title": "Home"
        }, 
        {
            "location": "/#revkit-user-guide", 
            "text": "This is intended to serve as an user guide for Revkit, a reversible logic toolkit program. Revkit is now a part of  CirKit , a toolkit program for logic created by Mathias Soeken at the \u00c9cole Polythechnique Fed\u00e9rale de Lausanne.  This user manual contains a list of most commands in Revkit along with their description, along with a section completely dedicated to examples of the code.", 
            "title": "Revkit user guide"
        }, 
        {
            "location": "/#about-the-installation", 
            "text": "Although in Cirkit's repository we can find instructions for installing Revkit, here we will detail how to make a clean installation of Revkit inside Ubuntu and inside the Uleth Linux System, a Centos7-based computer network designed for the Computer Science and Mathematics deparment memebers at the University of Lethbridge in Alberta, Canada.  Cirkit is supported by UNIX-like systems such as MacOS and Linux distributions.", 
            "title": "About the installation"
        }, 
        {
            "location": "/#requirements", 
            "text": "The following sofware is needed in order to build Revkit   git  cmake (at least version 3.0.0)  g++ (at least version 4.9.0) or clang++ (at least version 3.5.0)  boost (at least version 1.56.0)  GNU MP, and its C++ interface GMP++  GNU readline", 
            "title": "Requirements"
        }, 
        {
            "location": "/#internal-package-manager", 
            "text": "CirKit uses some external (mainly academic) programs that are typically not shipped with Linux distributions.  To ease their installation CirKit provides its own small package manager that can be invoked via  utils/tools.py .  Run      utils/tools.py commands  to see a document list of the options of this package manager and learn how it can be executed.  The programs are automatically downloaded and build, binaries are installed in the  ext/bin  folder of CirKit's main directory.  It must be noticed that, if we want to install a program through this package manager and then use in general in our system, we must update the  PATH  environment variable using the following command:  export   PATH = path-to-cirkit /ext/bin: $PATH ` .  This indicates the system to look for binaries of programs inside the  ext/bin  folder of CirKit's main repository before searching in system folders.", 
            "title": "Internal Package Manager"
        }, 
        {
            "location": "/#installation-in-ubuntu", 
            "text": "The following instructions for installing Revkit in Ubuntu are also included in CirKit's Github repository. First of all, we need to install the dependencies needed for Revkit using Ubuntu's package manager. The following command must be executed from a terminal:  sudo apt-get install build-essential git g++ cmake libboost-all-dev libgmp3-dev libxml2-dev zlib1g-dev lapack openblas  After installing these dependencies, we are ready for cloning the Github repository using the following command:   git clone https://github.com/msoeken/cirkit.git cd  cirkit  After this step, we need to create and update some environment variables of the system. To do that, run the following commands in the same terminal:  export   CIRKIT_HOME = full-path-to-cirkit-repository  export   LD_LIBRARY_PATH = $CIRKIT_HOME /ext/lib: $LD_LIBRARY_PATH  export   PATH = $CIRKIT_HOME /ext/bin: $PATH   Now, to install Revkit we must run the following commands from the terminal:  mkdir build cd  build\ncmake -Denable_cirkit-addon-reversible = ON -Denable_cirkit-addon-formal = ON ..\nmake external\nmake revkit  The first two commands create a directory called \"build\" inside of Cirkit main directory and changes the terminal location to it. The following three commands build Revkit from the cmake configuration files created along it.", 
            "title": "Installation in Ubuntu"
        }, 
        {
            "location": "/#manually-installing-boost", 
            "text": "Even though the Boost library installed from Ubuntu's package manager is higher than the requirement from Revkit (1.58.0 at Ubuntu;s package manager, Revkit requires higher than 1.56.0), this version is fairly old and it can cause some problems when installing Revkit. To avoid this problems, we recommend installing a newer version of Boost (1.64.0) by downloading it from their official website and then installing it. This can be accomplished with the following commands:  wget https://dl.bintray.com/boostorg/release/1.64.0/source/boost_1_64_0.tar.gz\ntar xzvf boost_1_64_0.tar.gz cd  boost_1_64_0.tar.gz/\nsudo apt-get update\nsudo apt-get install build-essential g++ python-dev autotools-dev libicu-dev build-essential libbz2-dev \n./bootstrap.sh --prefix = /usr/\n./b2\nsudo ./b2 install   The first three lines downloads, uncompress Boost and changes the terminal direction to Boost main directory. The following two lines use Ubuntu's package manager to install tools needed for Boosts installation. The last three lines compile and install Boost under the '/usr/' directory of the user.", 
            "title": "Manually installing Boost"
        }, 
        {
            "location": "/#installation-in-uleth-linux-system", 
            "text": "To install Revkit in ULeth linux system we face several problems due to the complexity of the system and to not having root permission. The problems can be listed as the following.   Disk quota issue:   The disk space available for each user at the ULeth linux system is low relatively to the system size (the installation is of around 2.5 GB). The solution to this is to install it locally on each computer you are working or using a shared partition in the system. For anyone without much experience with the system, the system administrator assistance is needed.  Dependencies issue:   although all of the dependencies needed to install the program are included in the system, some of them are not updated and can not be used safely by Revkit.   Compiling issues:  As a result of being written in C++, there can be problems compiling it if previous built has failed due to the usage of CCache by GCC. Basically, CCache stores compilations of C/C++ code so that compiling a program several times is made with lower downtime. However, for builds that have failed, CCache uses that same compilation so it forces that any further build have the same error, even if you have corrected it.    So solve the  Disk Quota issues , the first step in the installation is to a file location in the system must be found with enough free space (more than 3 GB) to clone the github repository and perform the installation. After that, clone the Github repository:  ~$ git clone https://github.com/msoeken/cirkit.git\n~$  cd  cirkit", 
            "title": "Installation in ULeth linux system"
        }, 
        {
            "location": "/#installing-dependencies", 
            "text": "Due to the high dependencies requirements of Cirkit, it can not be installed easily on a system without having root privileges to update and install all of the dependencies needed. However, it can be installed using the internal package manager. In the following we will list each dependency and its status at the ULeth linux system:   git :  included in the linux system and updated.  GNU MP and GMP++ :  included in the linux system and updated.  GNU readline :  included in the linux system and updated.  GCC :  included in the linux system but out of date. Cirkit requires a version higher than 4.9.0, meanwhile the system is at 4.8.5.  cmake :  included in the linux system but out of date. Revkit requires a version higher than 3.0.0 and the system is in 2.8.5.  boost :  included in the linux system but out of date. Revkit requires a version higher than 1.56.0 and the system is in 1.53.0.   Although it would seem that a simple update made by the system administrator would be enough to be able to install Revkit, Boost and C++ cannot be updated because it generates problems with other programs in the system.   Cirkit's included package manager allows us to install local versions of the needed programs without the use of root privileges. Inside the main directory of the repository, open a terminal and run the following commands:   utils/tools.py install boost\n utils/tools.py install gcc\n utils/tools.py install cmake  It is very likely that the terminal throws an error when installing  gcc , but this problem is not for installing GCC other than for installing other dependencies, in particular, for ISL. After this step, we need to create and update some environment variables of the system. To do that, run the following commands in the same terminal:  export   CIRKIT_HOME = full-path-to-cirkit-repository  export   LD_LIBRARY_PATH = $CIRKIT_HOME /ext/lib: $LD_LIBRARY_PATH  export   PATH = $CIRKIT_HOME /ext/bin: $PATH", 
            "title": "Installing dependencies"
        }, 
        {
            "location": "/#python-api", 
            "text": "Revkit can also be used inside Python as a module through an API. In order to build the Python API, we need to have installed  Pybind11 .  Pybind11  can be installed executing the following commands in any directory of the file system:  git clone https://github.com/pybind/pybind11.git cd  pybind11\nmkdir build cd  build\ncmake ..\nmake install  It is recommended that the  make install  command is executed as a root user.  It is also recommended to install  pybind11  package for your python distribution. This can be done through  pip  with the command   pip install pybind11  After installing  pybind11 , one can build the python API executing the following commands in Cirkit main directory:  mkdir build cd  build\ncmake -Denable_cirkit-addon-reversible = ON -Denable_cirkit-addon-formal = ON -Dcirkit_ENABLE_PYTHON_API = ON ..\nmake external\nmake revkit_python  The Python API will be build inside the  build/programs  folder of Cirkit's main repository. After running these commands, we need to update the  PYTHONPATH  environment variable so Python finds Revkit module each time we want to import it. This can be done permanently by adding the following line to the  .bashrc  file:  export   PYTHONPATH = $CIRKIT_HOME /build/programs", 
            "title": "Python API"
        }, 
        {
            "location": "/Basic Usage/", 
            "text": "Basic Usage\n\n\nExecuting Revkit\n\n\nRevkit is a command line based program, so it does not have a graphical user interface. When Revkit is executed from a terminal, a shell prompt is printed to the screen with the text \nrevkit\n that replace the current directory normally displayed by a terminal. \n\n\nTo get a list of all the commands and a short description of their usage, one must call the \nhelp\n command. To view more information of each command, run the command with the \n--help\n flag. In general, there are three ways to run a program in Revkit:\n\n\n\n\nInteractive mode:\n the default command line shell that it is described above. Every command must be written by the user. It is accessed by simply executing Revkit with its alias: \n\n\n\n\n~$ revkit\nrevkit\n  read_aiger file.aig\nrevkit\n  cone -o y\nrevkit\n  simulate -ad\nrevkit\n  quit\n~$\n\n\n\n\n\n\n\nBash mode:\n mode where a list of commands  are given to Revkit as command line arguments.To run this method, one must execute Revkit with a \n-c\n flag:\n\n\n\n\n~$ revkit -c \nread_aiger file.aig; cone -o y; simulate -at; quit\n\n\n\n\n\n\nIf you want that every command executed is printed on the screen, add the \n-e\n flag\n\n\n\n\nBatch mode:\n mode where the list of commands executed are read line by line from a text file. To run this method, one must use call revkit with a \n-f\n flag followed by the name of the file with the commands:\n\n\n\n\n~$ revkit -f commands.txt\n\n\n\n\n\nAs in bash mode, if you want to print every command used, you can add the \n-e\n flag.\n\n\nIt must be noticed that any line beginning with the \"#\" character will not be read by Revkit. This is particularly useful for making comments for scripts that will run in Batch mode.\n\n\n\n\nPython API mode:\n mode where we import Revkit as a Python module and work with it inside Python scripts or Jupyter Notebooks. For this mode, we need to install the Python API as detailed in the Installation page.\n\n\n\n\nIn this mode, every command from the command line interface is mapped to a method of the Python module. The flags and arguments of the commands become keywork arguments of the methods in the Python module. The flags become binary keyworkd arguments that can be set to \nTrue\n or \nFlase\n menwhile the arguments become normal keyword arguments that must be set to the value that we would give them in the command line. \n\n\nFor example the following Revkit code:\n\n\nrevkit\n tt --load 0xcafe\nrevkit\n convert --tt_to_aig\nrevkit\n lhrs --cut_size 3\nrevkit\n ps -c\n\n\n\n\n\nMust be executed in Python in the following way:\n\n\nimport\n \nrevkit\n\n\nrevkit\n.\ntt\n(\nload\n \n=\n \n\u201c\n0xcafe\n\u201d\n)\n\n\nrevkit\n.\nconvert\n(\ntt_to_aig\n \n=\n \nTrue\n)\n\n\nrevkit\n.\nlhrs\n(\ncut_size\n \n=\n \n3\n)\n\n\nstats\n \n=\n \nrevkit\n.\nps\n(\ncircuit\n \n=\n \nTrue\n)\n\n\n\n\n\n\nCreating logs\n\n\nPassing \n-l file.log\n to Revkit creates a log file of the session. This option is particularly useful in batch mode. The log file contains a JSON array with an entry for each command. Each entry contains at least the full command that was run and the time at which the command was started to execute. Some commands write additional data into the log file. \n\n\nFor example, \nps -a\n writes number of inputs, outputs, and AND gates of an AIG, and \nquit\n writes several information about the computer on which Revkit has been executed. Being a JSON array, the log file can be easily parsed as many programming languages have a JSON library.\n\\\n\\\nSome helper functions to parse the log file and, e.g., create ASCII tables from them can be found in \nutils/experiments.py\n. Further, the Python program \nutils/extract\\_script.py\n extracts a CirKit script file from the the log that can be run in batch mode. This can be helpful when logging an interactive session and then rerunning the commands:\n\n\n~/cirkit$ revkit -l session.log\nrevkit\n  read_aiger file.aig\nrevkit\n  ps -a\n...\nrevkit\n  quit\ncirkit$ utils/extract_script.py session.log \n session.cs\ncirkit$ revkit -f session.cs\n\n\n\n\n\nFor performing experimental evaluations, the following workflow is suggested. Create two Python programs (or any other programming language) called \nmake_script.py\n and \nmake_table.py\n. The program \nmake_script.py\n writes a CirKit script. The program \nmake_table.py\n reads the log file created for the script and prints out a table:\n\n\n~/cirkit$ ./make_script.cs experiments.cs\n~/cirkit$ revkit -f experiments.cs -l experiments.log\n~/cirkit$ ./make_table.cs experiments.log\n\n\n\n\n\nAliases\n\n\nIn a traditional programming language, an alias is a function that uses as a basis internal functions of the program to compute a not defined task. In a similar fashion, Revkit allows the definition of aliases: a group of commands and procedures grouped under a single key. An alias is created with the \nalias\n command of Revkit. To define an alias we need a key, a string with no spaces, and the list of commands executed by that key. For example:\n\n\nrevkit\n alias simul \nconvert --circuit_to_spec ; print -s\n\n\n\n\n\n\nNote that the command list has to be put into quotes if they contain any space. To add more flexibillity and options to the alias, one can use \nregular expressions\n:\n\n\nalias \n(\\\\w+) \n (\\\\w+) \n (\\\\w+)\n \nconvert --%1%_to_%2%; convert --%2%_to_%3%\n\n\n\n\n\n\nThe \nalias\n command only creates aliases for the current session of Revkit. To add an alias that will we global for all of Revkit's session, add the wished \nalias\n command to a new line of the \nalias\n text file located in cirkit's main repository.\n\n\nData Structures\n\n\nRevkit can manipulate and analize a good number of data structures that represent either a boolean function or a reversible circuit. The following table lists the data structures included in Revkit. \n\n\n\n\n\n\n\n\nData structure\n\n\nAccess options\n\n\n\n\n\n\n\n\n\n\nExpression\n\n\n-e\n,\n--expr\n\n\n\n\n\n\nAnd-inverter graph\n\n\n-a\n,\n--aig\n\n\n\n\n\n\nXOR majority graph\n\n\n-x\n,\n--xmg\n\n\n\n\n\n\nBinary decision diagram\n\n\n-b\n,\n--bdd\n\n\n\n\n\n\nReversible circuit\n\n\n-c\n,\n--circuit\n\n\n\n\n\n\nReversible specification\n\n\n-s\n,\n--spec\n\n\n\n\n\n\nBDD of a characteristic reversible function (RCBDD)\n\n\n-r\n,\n--rcbdd\n\n\n\n\n\n\n\n\nInput and Output\n\n\nIn general, in order to create an instance of a data structure in Revkit we need to import the data structure from a file format that describes the data structure. The expressions are the only structure that can be created inside of Revkit by using the \nexpr\n command. \n\n\nThe data structures can also be exported to this same file format. The following table lists all of the data structures input and output commands used in Revkit along with a short decription.\n\n\n\n\n\n\n\n\nData structure\n\n\nFormat\n\n\nInput function\n\n\nOutput function\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nReversible circuits\n\n\nREAL\n\n\nread_real\n\n\nwrite_real\n\n\nReversible circuit representation using different gates as basis. Part of \nRevlib\n supported \nformats\n.\n\n\n\n\n\n\nReversible specification\n\n\nSPEC\n\n\nread_spec\n\n\nwrite_spec\n\n\nTruth table of a reversible circuit. \nRevlib\n supported \nformats\n.\n\n\n\n\n\n\nBinary decision diagram\n\n\nPLA\n\n\nread_pla\n\n\nwrite_pla\n\n\nSum of products representation of a Boolean function. \nRevlib\n supported \nformats\n.\n\n\n\n\n\n\nXOR majority graph\n\n\nVerilog\n\n\nread_verilog -x\n\n\nwrite_verilog -x\n\n\nVerilog\n standard format for a XOR majority graph representation.\n\n\n\n\n\n\nAnd-inverter graph\n\n\nVerilog\n\n\nread_verilog -a\n\n\nwrite_verilog -a\n\n\nVerilog\n standard format for a And-inverter graph representation.\n\n\n\n\n\n\nAnd-inverter graph\n\n\nAIGER\n\n\nread_aiger\n\n\nwrite_aiger\n\n\nFormat developed for the \nAIGER utlity set\n.\n\n\n\n\n\n\nAnd-inverter graph\n\n\nBENCH\n\n\nread_bench\n\n\n-\n\n\nFormat developed for traditional circuits as part of the Berkeley's \nABC system\n.\n\n\n\n\n\n\n\n\nThe \"-\" sign indicates that no command exists.`\n\n\nThe precise details of the usage of the input and output functions and memory allocation of Revkit will be addressed in the next section.\n\n\nRevkit also includes some commands to output a reversible circuit data structure to formats of certain quantum computing softwares. The following table lists this commands along with its compatible software and some notes.\n\n\n\n\n\n\n\n\nOutput command\n\n\nSoftware\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nwrite_liquid\n\n\nLIQUi|\n (Liquid)\n\n\nSoftware architecture and toolsuite for quantum computing developed by Microsoft Research.\n\n\n\n\n\n\nwrite_projectq\n\n\nProjectQ\n\n\nOpen source software framework for quantum computing started at Swiss Federal Institute of Technology in Zurich\n\n\n\n\n\n\nwrite_quipper\n\n\nQuipper Language\n\n\nEmbedded, scalable functional programming language for quantum computing.\n\n\n\n\n\n\nwrite_qpic\n\n\nQpic\n\n\nPython based tool for drawing quantum circuits via Latex.\n\n\n\n\n\n\nwrite_numpy\n\n\nNumpy package for Python\n\n\nSimulation of a reversible circuit built using Numpy library in Python.\n\n\n\n\n\n\nwrite_tikz\n\n\nTikz package of Latex\n\n\nLatex package for making diagrams and drawings.\n\n\n\n\n\n\n\n\nMemory Stores\n\n\nEvery time we create an instance of a data structure in Revkit, this structure is saved in a stored in a fixed memory location called \nStore\n. A store can be thought of as an unfixed vector of elements of a given data structure. Each data structure has its own store. \n\n\nThe \nstore\n command is used to access and make changes over the stores of Revkit. All stores can hold more than one instance of its data structure. As most commands in Revkit take as an input a data structure, the input is not normally specified: each store has a pointer that each commands takes as an input when it reaches for that data structure as an input. This pointer can be set with the \ncurrent\n command .\n\n\nTo see a list all the elements in the store of a given data structure, execute the command \nstore --show\n followed by the access option of the data structure. For example:\n\n\nrevkit\n  store --show -c\n[i] circuits in store:\n     0: 7 lines, 55 gates\n     1: 5 lines, 2 gates\n  *  2: 4 lines, 3 gates\n\n\n\n\n\nThe \n*\n symbol shows which element to which element of the store is the pointer set. To change the element to which the pointer points, we use the \ncurrent\n command. This command takes as an argument the access option of the data structure store you wish to access and the number of the element in the store to which you want to set the pointer to point. \n\n\nrevkit\n  store --show -c\nrevkit\n  store --show -c\n[i] circuits in store:\n     0: 7 lines, 55 gates\n     1: 5 lines, 2 gates\n  *  2: 4 lines, 3 gates\nrevkit\n  current -c 1\nrevkit\n  store --show -c\n[i] circuits in store:\n     0: 7 lines, 55 gates\n  *  1: 5 lines, 2 gates\n     2: 4 lines, 3 gates\n\n\n\n\n\nAs we mentioned before, every command that takes a data structure as input and/or a data structure as output will read or overwrite the current element in the pointer of its store. For the input of most commands, this behaviour can not be modified. Most of the commands that output a data structure have an option with flag \n-n, --new\n that specifies that the output data structure is stored in a new element of the store. \n\n\nThis is particularly useful for the \nread_*\n commands. For example. if we have a circuit in store and call the \nread_real\n function on a file, the new circuit will be written in the pointer. But if we call the command with the flag \nread\\_real -n\n, it will be saved in a new element of the store.\n\n\nrevkit\n  read_real template1.real\nrevkit\n  read_real template2.real\nrevkit\n  store --show -c\n[i] circuits in store:\n  *  0: 3 lines, 2 gates\nrevkit\n  read_real template1.real\nrevkit\n  read_real -n template2.real\nrevkit\n  store --show -c\n[i] circuits in store:\n     0: 3 lines, 2 gates\n  *  1: 3 lines, 2 gates\n\n\n\n\n\nTo delete all the items in a store, call the \nstore\n command with the \n--clear\n flag followed by the access option of the data structure:\n\n\nrevkit\n  store --show -c\n[i] circuits in store:\n     0: 3 lines, 2 gates\n  *  1: 3 lines, 2 gates\nrevkit\n  store --clear -c\nrevkit\n  store --show -c\n[i] no circuits in store\n\n\n\n\n\nMost of Revkit commands are sufficiently specific function or name, like the synthesis commands, to need specification over which data structure are operating. However, there are a series of generic commands that can operate on every data structure so we must specify the access option of the store of the data structure over which we want the command to act. The following table lists this commands.\n\n\n\n\n\n\n\n\nCommand\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncurrent\n\n\nChanges the current store pointer\n\n\n\n\n\n\nprint\n\n\nPrints a textual ASCII representation of the current store element\n\n\n\n\n\n\nps\n\n\nPrints statistical information about the current store element\n\n\n\n\n\n\nshow\n\n\nVisualizes the current store element (writes to a dot file)\n\n\n\n\n\n\nstore\n\n\nShows and clears elements from the store\n\n\n\n\n\n\n\n\nMaking diagrams of circuits\n\n\nRevkit can also be used for creating diagrams of reversible circuits. The diagrams are created using Latex, in particular, the \nTikZ\n and \npreview\n packages. It is recommended to make a complete Tex installation on the computer via \nTexLive\n or \nMacTex\n. A full installation of Tex is available for all users in the ULeth Linux system.\n\n\nThere are two principal ways in wich we can convert a circuit stored in Revkit to a diagram.\n\n\nPNG via Qpic and Latex\n\n\nTo create a PNG image of our circuit we have to use a auxiliary program called \nQpic\n. This is a Python-based program used to draw quantum circuits. Installation instructions are available inside its Github repository. After installing Qpic and supposing that we have a\n.real\n file describing a circuit called \ncircuit.real\n, we can convert it to PNG using the following command:\n\n\n$ revkit -c \nread_real circuit.real; write_qpic circuit.qpic\n\n$ qpic circuit.qpic -f png -o circuit.png\n\n\n\n\n\nThe first command uses revkit to read the circuit and to output a .qpic file called \ncircuit.qpic\n. The second command calls qpic to convert the \ncircuit.qpic\n file into \ncircuit.png\n. The output file is specified with the \n-o\n arrgument as the output format is specified by the \n-f\n argument. Other outputs format include .tex,.pdf and .tikz.\n\n\nPDF via Latex\n\n\nTo create the drawing directly with Revkit to a .pdf file, we should use the following commands:\n\n\n$ revkit -c \nread_real circuit.real; write_tikz --standalone circuit.tex\n\n$ pdflatex circuit.tex\n\n\n\n\n\nThe first command uses revkit to read the circuit and to ouput a .tex file called \ncircuit.tex\n that is compiled by the second command to a .pdf file called \ncircuit.pdf\n that contains the drawing of the circuit. the \n--standalone\n indicates that the file created is going to be compiled alone and not as part of a larger Latex project.", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/Basic Usage/#basic-usage", 
            "text": "", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/Basic Usage/#executing-revkit", 
            "text": "Revkit is a command line based program, so it does not have a graphical user interface. When Revkit is executed from a terminal, a shell prompt is printed to the screen with the text  revkit  that replace the current directory normally displayed by a terminal.   To get a list of all the commands and a short description of their usage, one must call the  help  command. To view more information of each command, run the command with the  --help  flag. In general, there are three ways to run a program in Revkit:   Interactive mode:  the default command line shell that it is described above. Every command must be written by the user. It is accessed by simply executing Revkit with its alias:    ~$ revkit\nrevkit   read_aiger file.aig\nrevkit   cone -o y\nrevkit   simulate -ad\nrevkit   quit\n~$   Bash mode:  mode where a list of commands  are given to Revkit as command line arguments.To run this method, one must execute Revkit with a  -c  flag:   ~$ revkit -c  read_aiger file.aig; cone -o y; simulate -at; quit   If you want that every command executed is printed on the screen, add the  -e  flag   Batch mode:  mode where the list of commands executed are read line by line from a text file. To run this method, one must use call revkit with a  -f  flag followed by the name of the file with the commands:   ~$ revkit -f commands.txt  As in bash mode, if you want to print every command used, you can add the  -e  flag.  It must be noticed that any line beginning with the \"#\" character will not be read by Revkit. This is particularly useful for making comments for scripts that will run in Batch mode.   Python API mode:  mode where we import Revkit as a Python module and work with it inside Python scripts or Jupyter Notebooks. For this mode, we need to install the Python API as detailed in the Installation page.   In this mode, every command from the command line interface is mapped to a method of the Python module. The flags and arguments of the commands become keywork arguments of the methods in the Python module. The flags become binary keyworkd arguments that can be set to  True  or  Flase  menwhile the arguments become normal keyword arguments that must be set to the value that we would give them in the command line.   For example the following Revkit code:  revkit  tt --load 0xcafe\nrevkit  convert --tt_to_aig\nrevkit  lhrs --cut_size 3\nrevkit  ps -c  Must be executed in Python in the following way:  import   revkit  revkit . tt ( load   =   \u201c 0xcafe \u201d )  revkit . convert ( tt_to_aig   =   True )  revkit . lhrs ( cut_size   =   3 )  stats   =   revkit . ps ( circuit   =   True )", 
            "title": "Executing Revkit"
        }, 
        {
            "location": "/Basic Usage/#creating-logs", 
            "text": "Passing  -l file.log  to Revkit creates a log file of the session. This option is particularly useful in batch mode. The log file contains a JSON array with an entry for each command. Each entry contains at least the full command that was run and the time at which the command was started to execute. Some commands write additional data into the log file.   For example,  ps -a  writes number of inputs, outputs, and AND gates of an AIG, and  quit  writes several information about the computer on which Revkit has been executed. Being a JSON array, the log file can be easily parsed as many programming languages have a JSON library.\n\\\n\\\nSome helper functions to parse the log file and, e.g., create ASCII tables from them can be found in  utils/experiments.py . Further, the Python program  utils/extract\\_script.py  extracts a CirKit script file from the the log that can be run in batch mode. This can be helpful when logging an interactive session and then rerunning the commands:  ~/cirkit$ revkit -l session.log\nrevkit   read_aiger file.aig\nrevkit   ps -a\n...\nrevkit   quit\ncirkit$ utils/extract_script.py session.log   session.cs\ncirkit$ revkit -f session.cs  For performing experimental evaluations, the following workflow is suggested. Create two Python programs (or any other programming language) called  make_script.py  and  make_table.py . The program  make_script.py  writes a CirKit script. The program  make_table.py  reads the log file created for the script and prints out a table:  ~/cirkit$ ./make_script.cs experiments.cs\n~/cirkit$ revkit -f experiments.cs -l experiments.log\n~/cirkit$ ./make_table.cs experiments.log", 
            "title": "Creating logs"
        }, 
        {
            "location": "/Basic Usage/#aliases", 
            "text": "In a traditional programming language, an alias is a function that uses as a basis internal functions of the program to compute a not defined task. In a similar fashion, Revkit allows the definition of aliases: a group of commands and procedures grouped under a single key. An alias is created with the  alias  command of Revkit. To define an alias we need a key, a string with no spaces, and the list of commands executed by that key. For example:  revkit  alias simul  convert --circuit_to_spec ; print -s   Note that the command list has to be put into quotes if they contain any space. To add more flexibillity and options to the alias, one can use  regular expressions :  alias  (\\\\w+)   (\\\\w+)   (\\\\w+)   convert --%1%_to_%2%; convert --%2%_to_%3%   The  alias  command only creates aliases for the current session of Revkit. To add an alias that will we global for all of Revkit's session, add the wished  alias  command to a new line of the  alias  text file located in cirkit's main repository.", 
            "title": "Aliases"
        }, 
        {
            "location": "/Basic Usage/#data-structures", 
            "text": "Revkit can manipulate and analize a good number of data structures that represent either a boolean function or a reversible circuit. The following table lists the data structures included in Revkit.      Data structure  Access options      Expression  -e , --expr    And-inverter graph  -a , --aig    XOR majority graph  -x , --xmg    Binary decision diagram  -b , --bdd    Reversible circuit  -c , --circuit    Reversible specification  -s , --spec    BDD of a characteristic reversible function (RCBDD)  -r , --rcbdd", 
            "title": "Data Structures"
        }, 
        {
            "location": "/Basic Usage/#input-and-output", 
            "text": "In general, in order to create an instance of a data structure in Revkit we need to import the data structure from a file format that describes the data structure. The expressions are the only structure that can be created inside of Revkit by using the  expr  command.   The data structures can also be exported to this same file format. The following table lists all of the data structures input and output commands used in Revkit along with a short decription.     Data structure  Format  Input function  Output function  Notes      Reversible circuits  REAL  read_real  write_real  Reversible circuit representation using different gates as basis. Part of  Revlib  supported  formats .    Reversible specification  SPEC  read_spec  write_spec  Truth table of a reversible circuit.  Revlib  supported  formats .    Binary decision diagram  PLA  read_pla  write_pla  Sum of products representation of a Boolean function.  Revlib  supported  formats .    XOR majority graph  Verilog  read_verilog -x  write_verilog -x  Verilog  standard format for a XOR majority graph representation.    And-inverter graph  Verilog  read_verilog -a  write_verilog -a  Verilog  standard format for a And-inverter graph representation.    And-inverter graph  AIGER  read_aiger  write_aiger  Format developed for the  AIGER utlity set .    And-inverter graph  BENCH  read_bench  -  Format developed for traditional circuits as part of the Berkeley's  ABC system .     The \"-\" sign indicates that no command exists.`  The precise details of the usage of the input and output functions and memory allocation of Revkit will be addressed in the next section.  Revkit also includes some commands to output a reversible circuit data structure to formats of certain quantum computing softwares. The following table lists this commands along with its compatible software and some notes.     Output command  Software  Notes      write_liquid  LIQUi|  (Liquid)  Software architecture and toolsuite for quantum computing developed by Microsoft Research.    write_projectq  ProjectQ  Open source software framework for quantum computing started at Swiss Federal Institute of Technology in Zurich    write_quipper  Quipper Language  Embedded, scalable functional programming language for quantum computing.    write_qpic  Qpic  Python based tool for drawing quantum circuits via Latex.    write_numpy  Numpy package for Python  Simulation of a reversible circuit built using Numpy library in Python.    write_tikz  Tikz package of Latex  Latex package for making diagrams and drawings.", 
            "title": "Input and Output"
        }, 
        {
            "location": "/Basic Usage/#memory-stores", 
            "text": "Every time we create an instance of a data structure in Revkit, this structure is saved in a stored in a fixed memory location called  Store . A store can be thought of as an unfixed vector of elements of a given data structure. Each data structure has its own store.   The  store  command is used to access and make changes over the stores of Revkit. All stores can hold more than one instance of its data structure. As most commands in Revkit take as an input a data structure, the input is not normally specified: each store has a pointer that each commands takes as an input when it reaches for that data structure as an input. This pointer can be set with the  current  command .  To see a list all the elements in the store of a given data structure, execute the command  store --show  followed by the access option of the data structure. For example:  revkit   store --show -c\n[i] circuits in store:\n     0: 7 lines, 55 gates\n     1: 5 lines, 2 gates\n  *  2: 4 lines, 3 gates  The  *  symbol shows which element to which element of the store is the pointer set. To change the element to which the pointer points, we use the  current  command. This command takes as an argument the access option of the data structure store you wish to access and the number of the element in the store to which you want to set the pointer to point.   revkit   store --show -c\nrevkit   store --show -c\n[i] circuits in store:\n     0: 7 lines, 55 gates\n     1: 5 lines, 2 gates\n  *  2: 4 lines, 3 gates\nrevkit   current -c 1\nrevkit   store --show -c\n[i] circuits in store:\n     0: 7 lines, 55 gates\n  *  1: 5 lines, 2 gates\n     2: 4 lines, 3 gates  As we mentioned before, every command that takes a data structure as input and/or a data structure as output will read or overwrite the current element in the pointer of its store. For the input of most commands, this behaviour can not be modified. Most of the commands that output a data structure have an option with flag  -n, --new  that specifies that the output data structure is stored in a new element of the store.   This is particularly useful for the  read_*  commands. For example. if we have a circuit in store and call the  read_real  function on a file, the new circuit will be written in the pointer. But if we call the command with the flag  read\\_real -n , it will be saved in a new element of the store.  revkit   read_real template1.real\nrevkit   read_real template2.real\nrevkit   store --show -c\n[i] circuits in store:\n  *  0: 3 lines, 2 gates\nrevkit   read_real template1.real\nrevkit   read_real -n template2.real\nrevkit   store --show -c\n[i] circuits in store:\n     0: 3 lines, 2 gates\n  *  1: 3 lines, 2 gates  To delete all the items in a store, call the  store  command with the  --clear  flag followed by the access option of the data structure:  revkit   store --show -c\n[i] circuits in store:\n     0: 3 lines, 2 gates\n  *  1: 3 lines, 2 gates\nrevkit   store --clear -c\nrevkit   store --show -c\n[i] no circuits in store  Most of Revkit commands are sufficiently specific function or name, like the synthesis commands, to need specification over which data structure are operating. However, there are a series of generic commands that can operate on every data structure so we must specify the access option of the store of the data structure over which we want the command to act. The following table lists this commands.     Command  Description      current  Changes the current store pointer    print  Prints a textual ASCII representation of the current store element    ps  Prints statistical information about the current store element    show  Visualizes the current store element (writes to a dot file)    store  Shows and clears elements from the store", 
            "title": "Memory Stores"
        }, 
        {
            "location": "/Basic Usage/#making-diagrams-of-circuits", 
            "text": "Revkit can also be used for creating diagrams of reversible circuits. The diagrams are created using Latex, in particular, the  TikZ  and  preview  packages. It is recommended to make a complete Tex installation on the computer via  TexLive  or  MacTex . A full installation of Tex is available for all users in the ULeth Linux system.  There are two principal ways in wich we can convert a circuit stored in Revkit to a diagram.", 
            "title": "Making diagrams of circuits"
        }, 
        {
            "location": "/Basic Usage/#png-via-qpic-and-latex", 
            "text": "To create a PNG image of our circuit we have to use a auxiliary program called  Qpic . This is a Python-based program used to draw quantum circuits. Installation instructions are available inside its Github repository. After installing Qpic and supposing that we have a .real  file describing a circuit called  circuit.real , we can convert it to PNG using the following command:  $ revkit -c  read_real circuit.real; write_qpic circuit.qpic \n$ qpic circuit.qpic -f png -o circuit.png  The first command uses revkit to read the circuit and to output a .qpic file called  circuit.qpic . The second command calls qpic to convert the  circuit.qpic  file into  circuit.png . The output file is specified with the  -o  arrgument as the output format is specified by the  -f  argument. Other outputs format include .tex,.pdf and .tikz.", 
            "title": "PNG via Qpic and Latex"
        }, 
        {
            "location": "/Basic Usage/#pdf-via-latex", 
            "text": "To create the drawing directly with Revkit to a .pdf file, we should use the following commands:  $ revkit -c  read_real circuit.real; write_tikz --standalone circuit.tex \n$ pdflatex circuit.tex  The first command uses revkit to read the circuit and to ouput a .tex file called  circuit.tex  that is compiled by the second command to a .pdf file called  circuit.pdf  that contains the drawing of the circuit. the  --standalone  indicates that the file created is going to be compiled alone and not as part of a larger Latex project.", 
            "title": "PDF via Latex"
        }, 
        {
            "location": "/Examples/", 
            "text": "Examples\n\n\nThis sections presents several code recipes, along with screen shots of their execution on a terminal, for making some basic work inside Revkit. For all of these instances, we will use Revkit's interactive mode in order to see each command along with its input. \n\n\nFor the execution of these examples, we will supose that we are working on a directory that has three .real files describing circuits: \ncircuit1.real\n, \ncircuit2.real\n and \ncircuit3.real\n.\n\n\nLoad several data structures into stores and print statistics\n\n\nIn this example, we will read 3 different circuits into Revkit's circuit store, and we will print their statistics with the \nps\n function and their ASCII representation with the \nprint\n. The following code shows this proceedure done inside Revkit:\n\n\n~$ revkit\nrevkit\n #read each circuit\nrevkit\n read_real circuit1.real\nrevkit\n read_real -n circuit2.real\nrevkit\n read_real -n circuit3.real\nrevkit\n #show contents of the circuit store\nrevkit\n store --show -c\n[i] circuits in store:\n     0: 4 lines, 4 gates\n     1: 5 lines, 5 gates\n  *  2: 3 lines, 5 gates\nrevkit\n #print ASCII represntation\nrevkit\n print -c\n\u2015\u2295\u2015\u2015\u2015\u2015\u2015\u25cf\u2015\u2a2f\u2015\n\u2015\u2015\u2015\u2295\u2015\u2015\u2015\u2295\u2015\u25cb\u2015\n\u2015\u2015\u2015\u2015\u2015\u2295\u2015\u25cb\u2015\u2a2f\u2015\n\nrevkit\n #print statistiics\nrevkit\n ps -c\nLines:        3\nGates:        5\nT-count:      7\nLogic qubits: 4\nrevkit\n #change store pointer\nrevkit\n current -c 1\nrevkit\n print -c\n\u2015\u2a2f\u2015\u2015\u2015\u2295\u2015\u2015\u2015\u25cf\u2015\n\u2015\u2a2f\u2015\u2015\u2015\u2015\u2015\u25cf\u2015\u25cb\u2015\n\u2015\u2015\u2015\u2a2f\u2015\u2015\u2015\u2015\u2015\u25cf\u2015\n\u2015\u25cf\u2015\u2015\u2015\u2015\u2015\u2295\u2015\u2a2f\u2015\n\u2015\u25cb\u2015\u2a2f\u2015\u2015\u2015\u2015\u2015\u2a2f\u2015\n\nrevkit\n ps -c\nLines:        5\nGates:        5\nT-count:      23\nLogic qubits: 6\nrevkit\n current -c 0\nrevkit\n print -c\n\u2015\u25cf\u2015\u2015\u2015\u2295\u2015\u2015\u2015\n\u2015\u2015\u2015\u2295\u2015\u25cf\u2015\u2295\u2015\n\u2015\u2a2f\u2015\u2015\u2015\u2015\u2015\u25cb\u2015\n\u2015\u2a2f\u2015\u2015\u2015\u25cf\u2015\u2015\u2015\n\nrevkit\n ps -c\nLines:        4\nGates:        4\nT-count:      7\nLogic qubits: 4\n\n\n\n\n\nMaking diagrams\n\n\nMaking diagram with Qpic\n\n\nIn this example, we will first read a circuit into Revkit and then export it as a qpic file, then exit Revkit and use Qpic from terminal to convert it to create a PNG image. The following code shows this proceedure done inside Revkit:\n\n\n~$ revkit\nrevkit\n #read circuit\nrevkit\n read_real circuit1.real\nrevkit\n print -c\n\u2015\u25cf\u2015\u2015\u2015\u2295\u2015\u2015\u2015\n\u2015\u2015\u2015\u2295\u2015\u25cf\u2015\u2295\u2015\n\u2015\u2a2f\u2015\u2015\u2015\u2015\u2015\u25cb\u2015\n\u2015\u2a2f\u2015\u2015\u2015\u25cf\u2015\u2015\u2015\n\nrevkit\n #write qpic file of circuit\nrevkit\n write_qpic circuit1.qpic\nrevkit\n quit\n\n~$ #use qpic to convert the circuit to PNG\n~$ qpic circuit1.qpic -f png -o circuit1.png\n\n\n\n\n\nNote that in the \nqpic\n command the \n-f\n flag indicates output format and \n-o\n flag indicates output file name The following picture is the final PNG image made by Qpic, the \ncircuit1.png\n file.\n\n\n\n\n\n\n\n\nMaking diagram via Latex\n\n\nIn this example we will read a circuit into revkit, export it as a .tikz file and compile it with Pdflatex to produce a PDF drawing of the same. The following code shows this proceedure done inside Revkit:\n\n\n~$ revkit\nrevkit\n read_real circuit1.real\nrevkit\n print -c\n\u2015\u25cf\u2015\u2015\u2015\u2295\u2015\u2015\u2015\n\u2015\u2015\u2015\u2295\u2015\u25cf\u2015\u2295\u2015\n\u2015\u2a2f\u2015\u2015\u2015\u2015\u2015\u25cb\u2015\n\u2015\u2a2f\u2015\u2015\u2015\u25cf\u2015\u2015\u2015\n\nrevkit\n #write .tex file of the circuit ready to compile alone\nrevkit\n write_tikz --standalone circuit1.tex\nrevkit\n quit\n~$ #use pdflatex to compile the .tex file and don\nt print many lines during the process.\n~$ pdflatex -interaction=batchmode circuit1.tex\n\n\n\n\n\nThe following picture is the final PDF compiled by Pdflatex.\n\n\n\n\n\n\n\n\nObtain truth table of reversible circuit\n\n\nIn this example we will simulate a reversible circuit to obtain its truth table and then export it as a SPEC file. The following code shows this proceedure done inside Revkit:\n\n\nrevkit\n read_real circuit3.real\nrevkit\n print -c\n\u2015\u2295\u2015\u2015\u2015\u2015\u2015\u25cf\u2015\u2a2f\u2015\n\u2015\u2015\u2015\u2295\u2015\u2015\u2015\u2295\u2015\u25cb\u2015\n\u2015\u2015\u2015\u2015\u2015\u2295\u2015\u25cb\u2015\u2a2f\u2015\n\nrevkit\n # convert Negative controls to positive controls using NOT gates\nrevkit\n pos\nrevkit\n #simulate circuit\nrevkit\n convert --circuit_to_spec\nrevkit\n #print truth table on the command line\nrevkit\n print -s\n000 111\n001 001\n010 101\n011 110\n100 011\n101 010\n110 100\n111 000\n\nrevkit\n #export truth table to a SPEC file\nrevkit\n write_spec circuit3.spec\nrevkit\n quit\n\n\n\n\n\nNote that, as commented in the Reversible tools page, it is necessary to use the \npos\n before the \nconvert\n command to avoid problems. \n\n\nSynthesize circuit from truth table using Transformed based synthesis\n\n\nIn this example, we will use the SPEC file created in the previous example to synthesis a circuit using the \ntbs\n example for Transformation based synthesis. The following code shows this proceedure done inside Revkit:\n\n\n~$ revkit\nrevkit\n #read the truth table that we want to convert to synthesis\nrevkit\n read_spec circuit3.spec\nrevkit\n print -s\n000 111\n001 001\n010 101\n011 110\n100 011\n101 010\n110 100\n111 000\n\nrevkit\n #use transformation based synthesis to create a circuit\nrevkit\n tbs\n[i] run-time: 0.00 secs\nrevkit\n #print the circuit in the command line\nrevkit\n print -c\n\u2015\u2295\u2015\u25cf\u2015\u25cf\u2015\u25cf\u2015\u25cf\u2015\u2295\u2015\u25cf\u2015\u25cf\u2015\u2295\u2015\u2295\u2015\u25cf\u2015\u25cf\u2015\n\u2015\u25cf\u2015\u25cf\u2015\u2295\u2015\u2295\u2015\u25cf\u2015\u25cf\u2015\u2295\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2295\u2015\u25cf\u2015\n\u2015\u2015\u2015\u2295\u2015\u25cf\u2015\u2015\u2015\u2295\u2015\u25cf\u2015\u25cf\u2015\u2295\u2015\u25cf\u2015\u2015\u2015\u2015\u2015\u2295\u2015\n\nrevkit\n #read the original .real file of the circuit\nrevkit\n read_real -n circuit3.real\nrevkit\n # convert negative controls to positive controls and Fredkin to Toffoli for simulation\nrevkit\n pos\nrevkit\n tof\nrevkit\n # simulate both circuits and compare if they are equivalent\nrevkit\n rec --id1 0 --id2 1\n[i] run-time: 0.00 secs\n[i] circuits are equivalent", 
            "title": "Examples"
        }, 
        {
            "location": "/Examples/#examples", 
            "text": "This sections presents several code recipes, along with screen shots of their execution on a terminal, for making some basic work inside Revkit. For all of these instances, we will use Revkit's interactive mode in order to see each command along with its input.   For the execution of these examples, we will supose that we are working on a directory that has three .real files describing circuits:  circuit1.real ,  circuit2.real  and  circuit3.real .", 
            "title": "Examples"
        }, 
        {
            "location": "/Examples/#load-several-data-structures-into-stores-and-print-statistics", 
            "text": "In this example, we will read 3 different circuits into Revkit's circuit store, and we will print their statistics with the  ps  function and their ASCII representation with the  print . The following code shows this proceedure done inside Revkit:  ~$ revkit\nrevkit  #read each circuit\nrevkit  read_real circuit1.real\nrevkit  read_real -n circuit2.real\nrevkit  read_real -n circuit3.real\nrevkit  #show contents of the circuit store\nrevkit  store --show -c\n[i] circuits in store:\n     0: 4 lines, 4 gates\n     1: 5 lines, 5 gates\n  *  2: 3 lines, 5 gates\nrevkit  #print ASCII represntation\nrevkit  print -c\n\u2015\u2295\u2015\u2015\u2015\u2015\u2015\u25cf\u2015\u2a2f\u2015\n\u2015\u2015\u2015\u2295\u2015\u2015\u2015\u2295\u2015\u25cb\u2015\n\u2015\u2015\u2015\u2015\u2015\u2295\u2015\u25cb\u2015\u2a2f\u2015\n\nrevkit  #print statistiics\nrevkit  ps -c\nLines:        3\nGates:        5\nT-count:      7\nLogic qubits: 4\nrevkit  #change store pointer\nrevkit  current -c 1\nrevkit  print -c\n\u2015\u2a2f\u2015\u2015\u2015\u2295\u2015\u2015\u2015\u25cf\u2015\n\u2015\u2a2f\u2015\u2015\u2015\u2015\u2015\u25cf\u2015\u25cb\u2015\n\u2015\u2015\u2015\u2a2f\u2015\u2015\u2015\u2015\u2015\u25cf\u2015\n\u2015\u25cf\u2015\u2015\u2015\u2015\u2015\u2295\u2015\u2a2f\u2015\n\u2015\u25cb\u2015\u2a2f\u2015\u2015\u2015\u2015\u2015\u2a2f\u2015\n\nrevkit  ps -c\nLines:        5\nGates:        5\nT-count:      23\nLogic qubits: 6\nrevkit  current -c 0\nrevkit  print -c\n\u2015\u25cf\u2015\u2015\u2015\u2295\u2015\u2015\u2015\n\u2015\u2015\u2015\u2295\u2015\u25cf\u2015\u2295\u2015\n\u2015\u2a2f\u2015\u2015\u2015\u2015\u2015\u25cb\u2015\n\u2015\u2a2f\u2015\u2015\u2015\u25cf\u2015\u2015\u2015\n\nrevkit  ps -c\nLines:        4\nGates:        4\nT-count:      7\nLogic qubits: 4", 
            "title": "Load several data structures into stores and print statistics"
        }, 
        {
            "location": "/Examples/#making-diagrams", 
            "text": "", 
            "title": "Making diagrams"
        }, 
        {
            "location": "/Examples/#making-diagram-with-qpic", 
            "text": "In this example, we will first read a circuit into Revkit and then export it as a qpic file, then exit Revkit and use Qpic from terminal to convert it to create a PNG image. The following code shows this proceedure done inside Revkit:  ~$ revkit\nrevkit  #read circuit\nrevkit  read_real circuit1.real\nrevkit  print -c\n\u2015\u25cf\u2015\u2015\u2015\u2295\u2015\u2015\u2015\n\u2015\u2015\u2015\u2295\u2015\u25cf\u2015\u2295\u2015\n\u2015\u2a2f\u2015\u2015\u2015\u2015\u2015\u25cb\u2015\n\u2015\u2a2f\u2015\u2015\u2015\u25cf\u2015\u2015\u2015\n\nrevkit  #write qpic file of circuit\nrevkit  write_qpic circuit1.qpic\nrevkit  quit\n\n~$ #use qpic to convert the circuit to PNG\n~$ qpic circuit1.qpic -f png -o circuit1.png  Note that in the  qpic  command the  -f  flag indicates output format and  -o  flag indicates output file name The following picture is the final PNG image made by Qpic, the  circuit1.png  file.", 
            "title": "Making diagram with Qpic"
        }, 
        {
            "location": "/Examples/#making-diagram-via-latex", 
            "text": "In this example we will read a circuit into revkit, export it as a .tikz file and compile it with Pdflatex to produce a PDF drawing of the same. The following code shows this proceedure done inside Revkit:  ~$ revkit\nrevkit  read_real circuit1.real\nrevkit  print -c\n\u2015\u25cf\u2015\u2015\u2015\u2295\u2015\u2015\u2015\n\u2015\u2015\u2015\u2295\u2015\u25cf\u2015\u2295\u2015\n\u2015\u2a2f\u2015\u2015\u2015\u2015\u2015\u25cb\u2015\n\u2015\u2a2f\u2015\u2015\u2015\u25cf\u2015\u2015\u2015\n\nrevkit  #write .tex file of the circuit ready to compile alone\nrevkit  write_tikz --standalone circuit1.tex\nrevkit  quit\n~$ #use pdflatex to compile the .tex file and don t print many lines during the process.\n~$ pdflatex -interaction=batchmode circuit1.tex  The following picture is the final PDF compiled by Pdflatex.", 
            "title": "Making diagram via Latex"
        }, 
        {
            "location": "/Examples/#obtain-truth-table-of-reversible-circuit", 
            "text": "In this example we will simulate a reversible circuit to obtain its truth table and then export it as a SPEC file. The following code shows this proceedure done inside Revkit:  revkit  read_real circuit3.real\nrevkit  print -c\n\u2015\u2295\u2015\u2015\u2015\u2015\u2015\u25cf\u2015\u2a2f\u2015\n\u2015\u2015\u2015\u2295\u2015\u2015\u2015\u2295\u2015\u25cb\u2015\n\u2015\u2015\u2015\u2015\u2015\u2295\u2015\u25cb\u2015\u2a2f\u2015\n\nrevkit  # convert Negative controls to positive controls using NOT gates\nrevkit  pos\nrevkit  #simulate circuit\nrevkit  convert --circuit_to_spec\nrevkit  #print truth table on the command line\nrevkit  print -s\n000 111\n001 001\n010 101\n011 110\n100 011\n101 010\n110 100\n111 000\n\nrevkit  #export truth table to a SPEC file\nrevkit  write_spec circuit3.spec\nrevkit  quit  Note that, as commented in the Reversible tools page, it is necessary to use the  pos  before the  convert  command to avoid problems.", 
            "title": "Obtain truth table of reversible circuit"
        }, 
        {
            "location": "/Examples/#synthesize-circuit-from-truth-table-using-transformed-based-synthesis", 
            "text": "In this example, we will use the SPEC file created in the previous example to synthesis a circuit using the  tbs  example for Transformation based synthesis. The following code shows this proceedure done inside Revkit:  ~$ revkit\nrevkit  #read the truth table that we want to convert to synthesis\nrevkit  read_spec circuit3.spec\nrevkit  print -s\n000 111\n001 001\n010 101\n011 110\n100 011\n101 010\n110 100\n111 000\n\nrevkit  #use transformation based synthesis to create a circuit\nrevkit  tbs\n[i] run-time: 0.00 secs\nrevkit  #print the circuit in the command line\nrevkit  print -c\n\u2015\u2295\u2015\u25cf\u2015\u25cf\u2015\u25cf\u2015\u25cf\u2015\u2295\u2015\u25cf\u2015\u25cf\u2015\u2295\u2015\u2295\u2015\u25cf\u2015\u25cf\u2015\n\u2015\u25cf\u2015\u25cf\u2015\u2295\u2015\u2295\u2015\u25cf\u2015\u25cf\u2015\u2295\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2295\u2015\u25cf\u2015\n\u2015\u2015\u2015\u2295\u2015\u25cf\u2015\u2015\u2015\u2295\u2015\u25cf\u2015\u25cf\u2015\u2295\u2015\u25cf\u2015\u2015\u2015\u2015\u2015\u2295\u2015\n\nrevkit  #read the original .real file of the circuit\nrevkit  read_real -n circuit3.real\nrevkit  # convert negative controls to positive controls and Fredkin to Toffoli for simulation\nrevkit  pos\nrevkit  tof\nrevkit  # simulate both circuits and compare if they are equivalent\nrevkit  rec --id1 0 --id2 1\n[i] run-time: 0.00 secs\n[i] circuits are equivalent", 
            "title": "Synthesize circuit from truth table using Transformed based synthesis"
        }, 
        {
            "location": "/Reversible Tools/", 
            "text": "Development tools\n\n\nThis page presents a list of the development related commands of Revkit and their description\n\n\nMapping and rewriting\n\n\nRevkit provides us with a set of commands that can modify our reversible circuit in ways that can be helpful to us. Rewriting usually refers to changing the basis of a circuit while mapping refers to changing some elements in a reversible circuit for other. As mentioned before, each of these commands act on the circuit to which the circuit store pointer points to and overwrite this store with the output. In order to add it to the store, you must run the command with the \n-n\n flag.\n\n\nThe following table lists the commands and a basic description of its functions:\n\n\n\n\n\n\n\n\nCommand\n\n\ndescription\n\n\n\n\n\n\n\n\n\n\nconcat\n\n\nconcatenates two circuits in store that are given as arguments with flags \n--id1\n and \n--id2\n respectively. For example, let circuit in store \n0\n be \nG_1 \\dots G_k\n and circuit in store \n1\n be \nH_1 \\dots H_l\n. Executing \nconcat --id1 0 --id2 1\n overwrites the current pointer of the store with the circuit \nG_1 \\dots G_k H_1 \\dots H_l\n.\n\n\n\n\n\n\nfilter\n\n\nRemoves all gates from a circuit. This command is used to filter out non desired gates. It has a series of flags that indicate what gates to keep:\n\n\n\n\n\n\n\n\n-tof\n keep Toffoli gates\n\n\n\n\n\n\n\n\n-stg\n keep single-target gates\n\n\n\n\n\n\n\n\n-inv\n invert filter\n\n\n\n\n\n\nmaslov234\n\n\nMaslov's reversible phase gate mapping. For more intormation, consult \n1\n\n\n\n\n\n\nmitm\n\n\nsimple meet-in-the-middle mapping. For more information about the algorithm,  consult \n2\n\n\n\n\n\n\nnct\n\n\nchange each gate to its equivalent using the NOT, CNOT and Toffoli gates (NCT)\n\n\n\n\n\n\npos\n\n\nreplace negative controls with equivalent positive controls and NOT gates\n\n\n\n\n\n\nreverse\n\n\nreverse  a circuit. If a circuit is defined by gates \nG_1 G_2 \\dots G_k\n, this command outputs the circuit deffined by \nG_k G_{k-1` ... G_1\n\n\n\n\n\n\n\n\ntof\n\n\nrewrite Fredkin gates to Toffoli gates\n\n\n\n\n\n\nunique_names\n\n\nchanges the variable names of inputs, outputs. garbage and constants of the circuit as specified by it REAL file so that all the names are unique.\n\n\n\n\n\n\n\n\nSimulation and verification\n\n\nRevkit allows us to simulate a reversible circuit, that is, to verify and test its output for a certain input. We will discuss the commands that allow us to do that and how to use them. \n\n\nBefore continuing, it must be noticed that most Revkit's commands for simulation and verification, including the \nconvert\n command, which will be discussed in the following, throw errors when are called upon a circuit that has negative controls. It also can throw errors when the circuits are not based on Tofolli gates. For this reason, we strongly recommend to call the \npos\n and \nnct\n commands on every circuit each time one wants to simulate a circuit.\n\n\nThe following table lists all the simulation commands of Revkit, along with a short description.\n\n\n\n\n\n\n\n\ncommand\n\n\ndescription\n\n\n\n\n\n\n\n\n\n\nis_identity\n\n\nChecks if circuit in store computes the identity function.\n\n\n\n\n\n\nrec\n\n\nEquivalence checking for two circuits on store. The location in store of the circuits is given as arguments with flags \n--id1\n and \n--id2\n respectively. In order to use this command, the \ncryptominisat\n program must be installed and its executable must be added to the PATH variable. This can be done using CirKIt's package manager\n\n\n\n\n\n\nrevsim\n\n\nSimulate the output of \nn\n-bits for an \nn-\nline circuit in store. The input bit pattern must be specified by flag \n-p. --pattern\n followed by an \nn\n-bit string.\n\n\n\n\n\n\n\n\nIf, instead of simulating one input pattern using the \nrevsim\n command, one wants to obtain the full truth table the reversible circuit, the \nconvert\n command must be used. This command is discussed in the following section. \n\n\nThere are also a series of commands related to the optimization of reversible circuits implemented in Revkit. In a similar fashion of the simulation commands, each of these commands act over the circuit in the store to which the store pointer points to. The following table lists all the optimization commands in Revkit along with a short description.\n\n\n\n\n\n\n\n\nCommand\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nadding_lines\n\n\noptimization method that tries to reduce the quantum cost of a circuit by adding garbage lines to it. For a more detailed description of the method, consult \n3\n \n\n\n\n\n\n\nesop\n\n\noutputs a PLA file, an exclusive sum of products representation, from an and-inverter graph in store. The file name of the output must be specified in the command with the \n--filename\n flag. It optimizes the output using an EXORCISM algorithm. For a larger explanation of these minimization algorithms, please consult \n4\n \n.\n\n\n\n\n\n\nreduce_lines\n\n\noptimization method that tries to reduce the number of lines in a circuit by merging garbage and constant lines, or garbage and garbage lines. For a more detailed description of the method, consult \n5\n \n.\n\n\n\n\n\n\nrevsimp\n\n\noptimization tool that uses several methods, which include canclation of adjacent not gates, merging of Toffoli gates with same targets (similar to template matching) and re-synthesis of gates using EXORCISM, among others. The . If called with the \n-v, --verbose\n flag, the process is detailed on screen.\n\n\n\n\n\n\ntpar\n\n\npolynomial-time algorithm for optimizing quantum circuits that takes the actual implementation of fault-tolerant logical gates into consideration. To run this command, the \ntpar\n package must be installed using Cirkit's package manager. For a more detailed description of this method, consult \n6\n \n.\n\n\n\n\n\n\n\n\nConversion\n\n\nIt is possible to convert compatible data structures from one to other. The \nconvert\n command allows us to convert one data structure to another. The command needs to have specified as flag the input and output conversion data structures. After specifying this flag, the command takes as an input the pointer in the input data structure store. The output data structure is written to a new element of the output data structure store by default.\n\n\nThe following table lists of all the possible conversions that can be done with the \nconvert\n command, along with its flags.\n\n\n\n\n\n\n\n\nInput\n\n\nOutput\n\n\nFlag\n\n\n\n\n\n\n\n\n\n\nReversible circuit\n\n\nAid-inverter graph\n\n\n--circuit_to_aig\n\n\n\n\n\n\nReversible circuit\n\n\nBDD of a characteristic reversible function\n\n\n--circuit_to_rcbdd\n\n\n\n\n\n\nReversible circuit\n\n\nReversible specification\n\n\n--circuit_to_spec\n\n\n\n\n\n\nAid-inverter graph\n\n\nXOR majority graph\n\n\n--aig_to_xmg\n\n\n\n\n\n\nAid-inverter graph\n\n\nBinary decision diagram\n\n\n--aig_to_bdd\n\n\n\n\n\n\nExpression\n\n\nXOR majority graph\n\n\n--expr_to_xmg\n\n\n\n\n\n\nExpression\n\n\nBinary decision diagram\n\n\n--expr_to_bdd\n\n\n\n\n\n\nExpression\n\n\nReversible specification\n\n\n--expr_to_spec\n\n\n\n\n\n\nXOR majority graph\n\n\nExpression\n\n\n--xmg_to_expr\n\n\n\n\n\n\nXOR majority graph\n\n\nAid-inverter graph\n\n\n--xmg_to_aig\n\n\n\n\n\n\n\n\nIn particular, the \n--circuit_to_spec\n flag is particularly useful, because it allows us to simulate all the outcomes of a reversible circuit, that is, to obtain the truth table of a reversible circuit. The inverse process, to design a reversible circuit that has a determined truth table, is discussed in the following section.\n\n\nSynthesis\n\n\nIn traditional and reversible logic, circuit synthesis, or simply synthesis, is the process of designing a circuit that computes a desired Boolean function, i. e. that matches a given and arbitrary truth table. As this process is fundamental for the physical implementation of a digital circuit, synthesis is a very important task that can be made in very different ways in order to optimize or achieve certain desired results. \n\n\nMost of the reversible logic synthesis algorithms included in Revkit are too complex (most of them have a complete paper describing them) to be explained fully on here, so each one is referenced to its original source. A good resource for more information on each command is also found in Mathias Soeken's review of the \nstate of the art in reversible logic synthesis\n\n\nThe following table lists all of the synthesis commands in Revkit. Most of them need different data structures in store as input in order to perform the synthesis. They take as an input the pointer of the input data structure store. All of them can be called with the \n-v, --verbose\n flag so that it outputs more information over each step of the algorithm. \n\n\n\n\n\n\n\n\nCommand\n\n\nInput\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncbs\n\n\nAnd-inverter graph\n\n\nCircuit based synthesis. For more information about the algorithm, consult \n \n7\n \n\n\n\n\n\n\ndbs\n\n\nReversible specification\n\n\nDecomposition based synthesis. For more information about the algorithm,  consult \n \n8\n \n \n \n9\n \n\n\n\n\n\n\nrms\n\n\nReversible specification\n\n\nReed-Muller spectra-based synthesis. For more information about the algorithm,  consult \n \n10\n \n\n\n\n\n\n\ntbs\n\n\nReversible specification\n\n\nTransformation based synthesis. For more information about the algorithm,  consult \n \n11\n \n\n\n\n\n\n\nqbs\n\n\nBDD of a characteristic reverible function\n\n\nQuantum  Multiple-valued  Decision Diagrams based synthesis. For more information about the algorithm,  consult \n \n12\n \n\n\n\n\n\n\nexs\n\n\nReversible specification\n\n\nsynthesizes a minimal circuit (with respect to the number of gates) using the SAT-basedexact synthesis approach. For more information about the algorithm,  consult \n \n13\n \n.\n\n\n\n\n\n\nesopbs\n\n\n-\n\n\nESOP-based synthesis. It takes as an input a BDD represented by a PLA file. The \n--filename\n argument indicates the path of the file. For more information about the algorithm,  consult \n \n14\n \n\n\n\n\n\n\nlhrs\n\n\nAnd-inverter graph\n\n\nLook-up table (LUT) based hierarchical reversible synthesis. Fore more information, consult \n \n15\n \n \n \n16\n \n\n\n\n\n\n\ndxs\n\n\nXOR majority graph\n\n\nDirect XOR majority graph synthesis\n\n\n\n\n\n\n\n\nReferences\n\n\n1  \n  Maslov, D.  \nOn  the  advantages  of  using  relative  phase  Toffolis  with  an  application  to  multiple  control  Toffoli\noptimization\n. In: (2015).\ndoi\n:\n10.1103/PhysRevA.93.022311\n. eprint:\narXiv:1508.03273.\n\n\n2  \n   Amy, M. et al. \nA Meet-in-the-Middle Algorithm for Fast Synthesis of Depth-Optimal Quantum Circuits\n. In:\nIEEE\nTransactions on Computer-Aided Design of Integrated Circuits and Systems\n32.6 (June 2013), pp. 818\u2013830.\nissn\n: 0278-\n0070.\ndoi\n:\n10.1109/TCAD.2013.2244643\n\n\n3  \n Abdessaied, N. et al. \nReducing the Depth of Quantum Circuits Using Additional Circuit Lines\n. In:\nReversible\nComputation:  5th  International  Conference,  RC  2013,  Victoria,  BC,  Canada,  July  4-5,  2013.  Proceedings\n.  Berlin,\nHeidelberg: Springer Berlin Heidelberg, 2013, pp. 221\u2013233.\n\n\n4  \n Perkowski, M. and Mishchenko, A. . \nFast Heuristic Minimization of Exclusive-Sums-of-Products\n. In:\nProceedings of the\nRM\u20192001 Workshop\n. DAC \u201910. 2001\n\n\n5 \n    Wille, R. ; Soeken, M. and Drechsler, R. . \nReducing the Number of Lines in Reversible Circuits\n. In:\nProceedings of the 47th Design Automation Conference\n. DAC \u201910. Anaheim, California: ACM, 2010, pp. 647\u2013652\n\n\n6 \n  Amy, M.; Maslov, D. and Mosca, M. . \nPolynomial-time T-depth Optimization of Clifford+T circuits via\nMatroid Partitioning\n. In: (2013).\ndoi\n:\n10.1109/TCAD.2014.2341953\n. eprint:\narXiv:1303.2042\n\n\n7 \n  Soeken, M.  and Chattopadhyay,  A. . \nUnlocking Efficiency and Scalability of Reversible Logic Synthesis Using Conventional Logic Synthesis\n. In:\nProceedings  of  the  53rd  Annual  Design  Automation  Conference\n. DAC \u201916. Austin,\nTexas: ACM, 2016, 149:1\u2013149:6\n\n\n8 \nDe Vos, A. and Van Rentergem, Y. . \nYoung subgroups for reversible computers\n. In:\nAdvances in Mathematics of\nCommunications\n2.2 (2008), pp. 183\u2013200.\ndoi\n:\n10.3934/amc.2008.2.183\n\n\n9 \n Soeken, M et al. \nAncilla-free synthesis of large reversible functions using binary decision diagrams\n. In:\nJournal\nof Symbolic Computation\n73 (2016), pp. 1\u201326\n\n\n10 \n Maslov, D. ; Dueck, G. and Miller, M. . \nTechniques for the Synthesis of Reversible Toffoli Networks\n. In:\nACM\nTrans. Des. Autom. Electron. Syst.\n12.4 (Sept. 2007).\ndoi\n:\n10.1145/1278349.1278355\n\n\n11 \n  Miller, M. ; Maslov, D.  and Gerhard Dueck, G. . \nA Transformation Based Algorithm for Reversible Logic\nSynthesis\n. In:\nProceedings  of  the  40th  Annual  Design  Automation  Conference\n. DAC \u201903. Anaheim, CA, USA: ACM,\n2003, pp. 318\u2013323.\ndoi\n:\n10.1145/775832.775915\n.\n\n\n12 \n Miller, D.  and  Thornton, M. .  \nQMDD:  A  Decision  Diagram  Structure  for  Reversible  and  Quantum Circuits\n. In: Proceedings of the 36th International Symposium on Multiple-Valued Logic\n. ISMVL \u201906. Washington, DC,\nUSA: IEEE Computer Society, 2006, pp. 30\u2013.\nisbn\n: 0-7695-2532-6.\ndoi\n:\n10.1109/ISMVL.2006.35\n.\n\n\n13 \n Gro\u03b2e, D.  Et al.\n. \nExact Multiple-control Toffoli Network Synthesis with SAT Techniques\n. In:\nTrans. Comp.-Aided\nDes. Integ. Cir. Sys.\n28.5 (May 2009), pp. 703\u2013715.\ndoi\n:\n10.1109/TCAD.2009.2017215\n\n\n14 \nFazel, K ; Thornton, M. and Rice, R. . \nESOP-based Toffoli Gate Cascade Generation\n . In:\n2007 IEEE Pacific Rim\nConference  on  Communications,  Computers  and  Signal  Processing\n. Aug. 2007, pp. 206\u2013209.\ndoi\n:\n10.1109/PACRIM.\n2007.4313212\n.\n\n\n15 \n Soeken, M. et al. \nHierarchical Reversible Logic Synthesis Using LUTs\n . In:\nProceedings of the 54th Annual Design\nAutomation  Conference  2017\n. ACM, 2017, 78:1\u201378:6.\nisbn\n: 978-1-4503-4927-7.\ndoi\n:\n10.\n1145/3061639.3062261\n\n\n16 \nSoeken, M. et al.\n\nLogic Synthesis for Quantum Computing\n\n. 2017. eprint:\narXiv:1706.02721", 
            "title": "Reversible Tools"
        }, 
        {
            "location": "/Reversible Tools/#development-tools", 
            "text": "This page presents a list of the development related commands of Revkit and their description", 
            "title": "Development tools"
        }, 
        {
            "location": "/Reversible Tools/#mapping-and-rewriting", 
            "text": "Revkit provides us with a set of commands that can modify our reversible circuit in ways that can be helpful to us. Rewriting usually refers to changing the basis of a circuit while mapping refers to changing some elements in a reversible circuit for other. As mentioned before, each of these commands act on the circuit to which the circuit store pointer points to and overwrite this store with the output. In order to add it to the store, you must run the command with the  -n  flag.  The following table lists the commands and a basic description of its functions:     Command  description      concat  concatenates two circuits in store that are given as arguments with flags  --id1  and  --id2  respectively. For example, let circuit in store  0  be  G_1 \\dots G_k  and circuit in store  1  be  H_1 \\dots H_l . Executing  concat --id1 0 --id2 1  overwrites the current pointer of the store with the circuit  G_1 \\dots G_k H_1 \\dots H_l .    filter  Removes all gates from a circuit. This command is used to filter out non desired gates. It has a series of flags that indicate what gates to keep:     -tof  keep Toffoli gates     -stg  keep single-target gates     -inv  invert filter    maslov234  Maslov's reversible phase gate mapping. For more intormation, consult  1    mitm  simple meet-in-the-middle mapping. For more information about the algorithm,  consult  2    nct  change each gate to its equivalent using the NOT, CNOT and Toffoli gates (NCT)    pos  replace negative controls with equivalent positive controls and NOT gates    reverse  reverse  a circuit. If a circuit is defined by gates  G_1 G_2 \\dots G_k , this command outputs the circuit deffined by  G_k G_{k-1` ... G_1     tof  rewrite Fredkin gates to Toffoli gates    unique_names  changes the variable names of inputs, outputs. garbage and constants of the circuit as specified by it REAL file so that all the names are unique.", 
            "title": "Mapping and rewriting"
        }, 
        {
            "location": "/Reversible Tools/#simulation-and-verification", 
            "text": "Revkit allows us to simulate a reversible circuit, that is, to verify and test its output for a certain input. We will discuss the commands that allow us to do that and how to use them.   Before continuing, it must be noticed that most Revkit's commands for simulation and verification, including the  convert  command, which will be discussed in the following, throw errors when are called upon a circuit that has negative controls. It also can throw errors when the circuits are not based on Tofolli gates. For this reason, we strongly recommend to call the  pos  and  nct  commands on every circuit each time one wants to simulate a circuit.  The following table lists all the simulation commands of Revkit, along with a short description.     command  description      is_identity  Checks if circuit in store computes the identity function.    rec  Equivalence checking for two circuits on store. The location in store of the circuits is given as arguments with flags  --id1  and  --id2  respectively. In order to use this command, the  cryptominisat  program must be installed and its executable must be added to the PATH variable. This can be done using CirKIt's package manager    revsim  Simulate the output of  n -bits for an  n- line circuit in store. The input bit pattern must be specified by flag  -p. --pattern  followed by an  n -bit string.     If, instead of simulating one input pattern using the  revsim  command, one wants to obtain the full truth table the reversible circuit, the  convert  command must be used. This command is discussed in the following section.   There are also a series of commands related to the optimization of reversible circuits implemented in Revkit. In a similar fashion of the simulation commands, each of these commands act over the circuit in the store to which the store pointer points to. The following table lists all the optimization commands in Revkit along with a short description.     Command  Description      adding_lines  optimization method that tries to reduce the quantum cost of a circuit by adding garbage lines to it. For a more detailed description of the method, consult  3      esop  outputs a PLA file, an exclusive sum of products representation, from an and-inverter graph in store. The file name of the output must be specified in the command with the  --filename  flag. It optimizes the output using an EXORCISM algorithm. For a larger explanation of these minimization algorithms, please consult  4   .    reduce_lines  optimization method that tries to reduce the number of lines in a circuit by merging garbage and constant lines, or garbage and garbage lines. For a more detailed description of the method, consult  5   .    revsimp  optimization tool that uses several methods, which include canclation of adjacent not gates, merging of Toffoli gates with same targets (similar to template matching) and re-synthesis of gates using EXORCISM, among others. The . If called with the  -v, --verbose  flag, the process is detailed on screen.    tpar  polynomial-time algorithm for optimizing quantum circuits that takes the actual implementation of fault-tolerant logical gates into consideration. To run this command, the  tpar  package must be installed using Cirkit's package manager. For a more detailed description of this method, consult  6   .", 
            "title": "Simulation and verification"
        }, 
        {
            "location": "/Reversible Tools/#conversion", 
            "text": "It is possible to convert compatible data structures from one to other. The  convert  command allows us to convert one data structure to another. The command needs to have specified as flag the input and output conversion data structures. After specifying this flag, the command takes as an input the pointer in the input data structure store. The output data structure is written to a new element of the output data structure store by default.  The following table lists of all the possible conversions that can be done with the  convert  command, along with its flags.     Input  Output  Flag      Reversible circuit  Aid-inverter graph  --circuit_to_aig    Reversible circuit  BDD of a characteristic reversible function  --circuit_to_rcbdd    Reversible circuit  Reversible specification  --circuit_to_spec    Aid-inverter graph  XOR majority graph  --aig_to_xmg    Aid-inverter graph  Binary decision diagram  --aig_to_bdd    Expression  XOR majority graph  --expr_to_xmg    Expression  Binary decision diagram  --expr_to_bdd    Expression  Reversible specification  --expr_to_spec    XOR majority graph  Expression  --xmg_to_expr    XOR majority graph  Aid-inverter graph  --xmg_to_aig     In particular, the  --circuit_to_spec  flag is particularly useful, because it allows us to simulate all the outcomes of a reversible circuit, that is, to obtain the truth table of a reversible circuit. The inverse process, to design a reversible circuit that has a determined truth table, is discussed in the following section.", 
            "title": "Conversion"
        }, 
        {
            "location": "/Reversible Tools/#synthesis", 
            "text": "In traditional and reversible logic, circuit synthesis, or simply synthesis, is the process of designing a circuit that computes a desired Boolean function, i. e. that matches a given and arbitrary truth table. As this process is fundamental for the physical implementation of a digital circuit, synthesis is a very important task that can be made in very different ways in order to optimize or achieve certain desired results.   Most of the reversible logic synthesis algorithms included in Revkit are too complex (most of them have a complete paper describing them) to be explained fully on here, so each one is referenced to its original source. A good resource for more information on each command is also found in Mathias Soeken's review of the  state of the art in reversible logic synthesis  The following table lists all of the synthesis commands in Revkit. Most of them need different data structures in store as input in order to perform the synthesis. They take as an input the pointer of the input data structure store. All of them can be called with the  -v, --verbose  flag so that it outputs more information over each step of the algorithm.      Command  Input  Description      cbs  And-inverter graph  Circuit based synthesis. For more information about the algorithm, consult    7      dbs  Reversible specification  Decomposition based synthesis. For more information about the algorithm,  consult    8       9      rms  Reversible specification  Reed-Muller spectra-based synthesis. For more information about the algorithm,  consult    10      tbs  Reversible specification  Transformation based synthesis. For more information about the algorithm,  consult    11      qbs  BDD of a characteristic reverible function  Quantum  Multiple-valued  Decision Diagrams based synthesis. For more information about the algorithm,  consult    12      exs  Reversible specification  synthesizes a minimal circuit (with respect to the number of gates) using the SAT-basedexact synthesis approach. For more information about the algorithm,  consult    13   .    esopbs  -  ESOP-based synthesis. It takes as an input a BDD represented by a PLA file. The  --filename  argument indicates the path of the file. For more information about the algorithm,  consult    14      lhrs  And-inverter graph  Look-up table (LUT) based hierarchical reversible synthesis. Fore more information, consult    15       16      dxs  XOR majority graph  Direct XOR majority graph synthesis", 
            "title": "Synthesis"
        }, 
        {
            "location": "/Reversible Tools/#references", 
            "text": "1     Maslov, D.   On  the  advantages  of  using  relative  phase  Toffolis  with  an  application  to  multiple  control  Toffoli\noptimization . In: (2015).\ndoi\n:\n10.1103/PhysRevA.93.022311\n. eprint:\narXiv:1508.03273.  2      Amy, M. et al.  A Meet-in-the-Middle Algorithm for Fast Synthesis of Depth-Optimal Quantum Circuits . In:\nIEEE\nTransactions on Computer-Aided Design of Integrated Circuits and Systems\n32.6 (June 2013), pp. 818\u2013830.\nissn\n: 0278-\n0070.\ndoi\n:\n10.1109/TCAD.2013.2244643  3    Abdessaied, N. et al.  Reducing the Depth of Quantum Circuits Using Additional Circuit Lines . In:\nReversible\nComputation:  5th  International  Conference,  RC  2013,  Victoria,  BC,  Canada,  July  4-5,  2013.  Proceedings\n.  Berlin,\nHeidelberg: Springer Berlin Heidelberg, 2013, pp. 221\u2013233.  4    Perkowski, M. and Mishchenko, A. .  Fast Heuristic Minimization of Exclusive-Sums-of-Products . In:\nProceedings of the\nRM\u20192001 Workshop\n. DAC \u201910. 2001  5      Wille, R. ; Soeken, M. and Drechsler, R. .  Reducing the Number of Lines in Reversible Circuits . In:\nProceedings of the 47th Design Automation Conference\n. DAC \u201910. Anaheim, California: ACM, 2010, pp. 647\u2013652  6    Amy, M.; Maslov, D. and Mosca, M. .  Polynomial-time T-depth Optimization of Clifford+T circuits via\nMatroid Partitioning . In: (2013).\ndoi\n:\n10.1109/TCAD.2014.2341953\n. eprint:\narXiv:1303.2042  7    Soeken, M.  and Chattopadhyay,  A. .  Unlocking Efficiency and Scalability of Reversible Logic Synthesis Using Conventional Logic Synthesis . In:\nProceedings  of  the  53rd  Annual  Design  Automation  Conference\n. DAC \u201916. Austin,\nTexas: ACM, 2016, 149:1\u2013149:6  8  De Vos, A. and Van Rentergem, Y. .  Young subgroups for reversible computers . In:\nAdvances in Mathematics of\nCommunications\n2.2 (2008), pp. 183\u2013200.\ndoi\n:\n10.3934/amc.2008.2.183  9   Soeken, M et al.  Ancilla-free synthesis of large reversible functions using binary decision diagrams . In:\nJournal\nof Symbolic Computation\n73 (2016), pp. 1\u201326  10   Maslov, D. ; Dueck, G. and Miller, M. .  Techniques for the Synthesis of Reversible Toffoli Networks . In:\nACM\nTrans. Des. Autom. Electron. Syst.\n12.4 (Sept. 2007).\ndoi\n:\n10.1145/1278349.1278355  11    Miller, M. ; Maslov, D.  and Gerhard Dueck, G. .  A Transformation Based Algorithm for Reversible Logic\nSynthesis . In:\nProceedings  of  the  40th  Annual  Design  Automation  Conference\n. DAC \u201903. Anaheim, CA, USA: ACM,\n2003, pp. 318\u2013323.\ndoi\n:\n10.1145/775832.775915\n.  12   Miller, D.  and  Thornton, M. .   QMDD:  A  Decision  Diagram  Structure  for  Reversible  and  Quantum Circuits . In: Proceedings of the 36th International Symposium on Multiple-Valued Logic\n. ISMVL \u201906. Washington, DC,\nUSA: IEEE Computer Society, 2006, pp. 30\u2013.\nisbn\n: 0-7695-2532-6.\ndoi\n:\n10.1109/ISMVL.2006.35\n.  13   Gro\u03b2e, D.  Et al.\n.  Exact Multiple-control Toffoli Network Synthesis with SAT Techniques . In:\nTrans. Comp.-Aided\nDes. Integ. Cir. Sys.\n28.5 (May 2009), pp. 703\u2013715.\ndoi\n:\n10.1109/TCAD.2009.2017215  14  Fazel, K ; Thornton, M. and Rice, R. .  ESOP-based Toffoli Gate Cascade Generation  . In:\n2007 IEEE Pacific Rim\nConference  on  Communications,  Computers  and  Signal  Processing\n. Aug. 2007, pp. 206\u2013209.\ndoi\n:\n10.1109/PACRIM.\n2007.4313212\n.  15   Soeken, M. et al.  Hierarchical Reversible Logic Synthesis Using LUTs  . In:\nProceedings of the 54th Annual Design\nAutomation  Conference  2017\n. ACM, 2017, 78:1\u201378:6.\nisbn\n: 978-1-4503-4927-7.\ndoi\n:\n10.\n1145/3061639.3062261  16  Soeken, M. et al. Logic Synthesis for Quantum Computing \n. 2017. eprint:\narXiv:1706.02721", 
            "title": "References"
        }
    ]
}